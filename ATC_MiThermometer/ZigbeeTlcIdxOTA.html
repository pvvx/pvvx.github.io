<!DOCTYPE html>
<html class="telFlasherClass">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="styles.css">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ZigbeeTLc Index Configurator for Zigbee OTA v0.0</title>
</head>
<body>
<script>
var $ = function(id) { return document.getElementById(id);}
var firmwareArray = "";
var fzigbeeota = { used : false };
//var fwname = '';
const MAX_FW_OTA_SIZE = 0x32000; // 200KB

function addLog(logTXT) {
	var time = new Date().toLocaleTimeString();
	var logString = time + ": " + logTXT;
	$("log").innerHTML += logString + "<br>";
}

function addClog(logTXT) {
	console.log(logTXT);
}

function addAlog(logTXT) {
	console.log(logTXT);
	addLog(logTXT);
}

function clearLog() {
	$("log").innerHTML = "";
}

function setStatus(status) {
	addClog("Status: " + status);
	$("percent").innerHTML = "Status: " + status;
}

function updateFail(err) {
	addLog("Update error: " + err);
	setStatus("Update error: " + err);
}

function decimalToHex(d, padding) {
	var hex = Number(d).toString(16);
	while (hex.length < 4) {
		hex = "0" + hex;
	}
	return hex;
}

function hex(number, len) {
	var str = (number.toString(16)).toUpperCase();
	while (str.length < len) str = '0' + str;
	return str;
}

function hexToBytes(hex) {
	for (var bytes = [], c = 0; c < hex.length; c += 2)
		bytes.push(parseInt(hex.substr(c, 2), 16));
	return new Uint8Array(bytes);
}

function bytesToHex(data) {
	return new Uint8Array(data).reduce(function(memo, i) {
		return memo + ("0" + i.toString(16)).slice(-2);
	}, "");
}

function hex2ascii(hexx) {
	var hex = hexx.toString();
	var str = '';
	for (var i = 0;
		(i < hex.length && hex.substr(i, 2) !== '00'); i += 2)
		str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
	return str;
}
var crc32 = (function() {
	let table = new Uint32Array(256);
	for(var i=256; i--;) {
		let tmp = i;
		for(let k=8; k--;) {
			tmp = tmp & 1 ? 0xEDB88320 ^ tmp >>> 1 : tmp >>> 1;
		}
		table[i] = tmp;
	}
	return function( data ) {
		let crc = -1;
		let l = data.length;
		for(let i=0; i<l; i++) {
			crc = crc >>> 8 ^ table[ crc & 255 ^ data[i] ];
		}
		return (crc >>> 0);
	};
})();


//-------------------------------------------------------------------------------------
function saveBinaryFile(blob, filename) {
    //const blob = new Blob([data], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);

    URL.revokeObjectURL(url);
}

function downloadFile(filename, content, type = 'text/plain') {
    const blob = new Blob([content], { type: type });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    console.log("a.download:"+a.download);
    document.body.removeChild(a);
    URL.revokeObjectURL(url); // Clean up the URL object
}


function showZigbeeHeaderValues() {
	if(fzigbeeota.used) {
		$("h_stack_version").value = "0x" + hex(fzigbeeota.stack_version,4);
		$("h_man_code").value = "0x" + hex(fzigbeeota.man_code,4);
		$("h_image_type").value = "0x" + hex(fzigbeeota.image_type,4);
		$("h_fwversion").value = "0x" + hex(fzigbeeota.fwversion,8);
		$("h_head_str").value = fzigbeeota.head_str;
	}
}

function ReadZigbeeHeaderValues() {
	let x = $("h_stack_version").value;
	if(x != "")	{ fzigbeeota.stack_version = parseInt(x);
		if(isNaN(fzigbeeota.stack_version) || fzigbeeota.stack_version == 0)
		   fzigbeeota.stack_version = 2;
	} else fzigbeeota.stack_version = 2;
	x = $("h_man_code").value;
	if(x != "")	{ fzigbeeota.man_code = parseInt(x);
		if(isNaN(fzigbeeota.man_code)) { addAlog("Error Manufacture code!"); return false; };
	} else { addAlog("Set Manufacture code!"); return false; };
	x = $("h_image_type").value;
	if(x != "")	{ fzigbeeota.image_type = parseInt(x);
		if(isNaN(fzigbeeota.image_type)) { addAlog("Error Image Type!"); return false; };
	} else { addAlog("Set Image Type!"); return false; };
	x = $("h_fwversion").value;
	if(x != "") { fzigbeeota.fwversion = parseInt(x); 
		if(isNaN(fzigbeeota.fwversion)) { addAlog("Error FW and Stack version!"); return false; };
	} else { addAlog("Set FW and Stack version!"); return false; };
	fzigbeeota.head_str = $("h_head_str").value;
	return true;
}

function createZigbeeHeader() {
	let blk = new Uint8Array(0x3e);
	blk.set((new TextEncoder()).encode(fzigbeeota.head_str), 0x14, 0x34);
	let head = new DataView(blk.buffer);
	head.setUint32(0, 0x0beef11e, true); // Zigbee OTA
	head.setUint16(4, 0x100, true); // header version is 0x0100
	head.setUint16(6, 56, true); // header size
	//head.setUint16(8, 0, true); //	ota_ext_hdr_value if ota_ext_hdr else 0,
	head.setUint16(0x0a, fzigbeeota.man_code, true);
	head.setUint16(0x0c, fzigbeeota.image_type, true);
	head.setUint32(0x0e, fzigbeeota.fwversion, true);
	head.setUint16(0x12, fzigbeeota.stack_version, true);
	fzigbeeota.head = head;
	// head_str
	head.setUint32(0x34, fzigbeeota.fwsize + 62, true);
	head.setUint32(0x3a, fzigbeeota.fwsize, true);
	fzigbeeota.used = true;
}

function menuUpgrade() {
	showZigbeeHeaderValues();
}

function savefw() {
	fzigbeeota.used = ReadZigbeeHeaderValues();
	if(fzigbeeota.used) {
		showZigbeeHeaderValues();
		let fwname = "-new";
		if(fzigbeeota.head_str_name != "")
			fwname = "-" + fzigbeeota.head_str_name + "-new";
		let fname = hex(fzigbeeota.man_code,4)
			+"-"+hex(fzigbeeota.image_type,4)
			+"-"+hex(fzigbeeota.fwversion,8)
			+ fwname
			+".zigbee";
		addAlog("Greate header file: "+fname);
		createZigbeeHeader();
		addAlog("Save file...");
    	const blob = new Blob([new Uint8Array(fzigbeeota.head.buffer), new Uint8Array(fzigbeeota.data)], { type: 'application/octet-stream' });
		saveBinaryFile(blob, fname);
	}
}
function testOTAFirmware(data, fname) {
	fzigbeeota = { used : false };
	let fsize = data.byteLength;
	addClog("File size = 0x"+ fsize.toString(16));
	if (fsize < 1024)
		return "Wrong binary Telink OTA firmware size!";
	let head = new DataView(data, 0, 0x3e);
	if(head.getUint32(0, true) == 0x0beef11e) { // Zigbee OTA
		if(head.getUint16(4, true) != 0x100	|| head.getUint16(6, true) != 56)
			return "Unknown Zigbee OTA header!";
		fzigbeeota.size = head.getUint32(0x3A, true);
		if(fzigbeeota.size < 2048 || fzigbeeota.size + 0x3e > fsize)
			return "Wrong binary Zigbee OTA firmware size!";
		fzigbeeota.man_code = head.getUint16(0x0a, true);
		fzigbeeota.image_type = head.getUint16(0x0c, true);
		fzigbeeota.fwversion = head.getUint32(0x0e, true);
		fzigbeeota.stack_version = head.getUint16(0x12, true);
		fzigbeeota.head_str = (new TextDecoder("utf-8").decode(head.buffer.slice(0x14,0x34))).split('\u0000')[0];
		if(fzigbeeota.head_str) {
			fzigbeeota.head_str_name = fzigbeeota.head_str.substring(fzigbeeota.head_str.lastIndexOf(':')+1);
			if(fzigbeeota.head_str_name)
				fzigbeeota.head_str_man = fzigbeeota.head_str.substring(0, fzigbeeota.head_str.indexOf(':'));
			else { fzigbeeota.head_str_man = ""; fzigbeeota.head_str_name = ""; };
		} else { fzigbeeota.head_str = ""; fzigbeeota.head_str_man = ""; fzigbeeota.head_str_name = ""; };
		fsize = fzigbeeota.size;
		addAlog("Zigbee OTA Info: ManCode: 0x"+hex(fzigbeeota.man_code, 4)+ ", ImageType: 0x" + hex(fzigbeeota.image_type,4) + ", FwVer: 0x" + hex(fzigbeeota.fwversion, 8));
		addAlog("APP Release: " + ((fzigbeeota.fwversion >> 28)&0x0f) + "." + ((fzigbeeota.fwversion >> 24)&0x0f)
		+ " Build: " + ((fzigbeeota.fwversion >> 20)&0x0f) + "." + ((fzigbeeota.fwversion >> 16)&0x0f)
		+ ", Stack Version: " + ((fzigbeeota.fwversion >> 12)&0x0f) + "." + ((fzigbeeota.fwversion >> 8)&0x0f)
		+ " Release: " + ((fzigbeeota.fwversion >> 4)&0x0f) + "." + (fzigbeeota.fwversion&0x0f));
		addAlog("Header String: "+ fzigbeeota.head_str);
		if(fzigbeeota.fsize > MAX_FW_OTA_SIZE) // 200KB
			return "Size firmware is more "+(MAX_FW_OTA_SIZE/1024)+"kbytes!";
		fzigbeeota.head = new DataView(data, 0, 0x3e);
		fzigbeeota.used = true;
		data = data.slice(0x3e);
	 	head = new DataView(data, 0, 0x3e);
	} else { // .bin file
		fzigbeeota.used = false;
		if (fsize > MAX_FW_OTA_SIZE) // 208KB
			return "Size firmware is more "+(MAX_FW_OTA_SIZE/1024)+" kbytes!";
		let fn = fname.substring(fname.lastIndexOf('/')+1);
		fzigbeeota.head_str_man = ""; 
		fzigbeeota.head_str_name = fn.substring(0, fn.lastIndexOf('.'));
		if(!fzigbeeota.head_str_name)
			fzigbeeota.head_str_name = fn.substring(fn.lastIndexOf('.')+1);
		if(fzigbeeota.head_str_name) {
			fzigbeeota.head_str = ":" + fzigbeeota.head_str_name;
		} else  fzigbeeota.head_str_name = "";
	}
	console.log("head_str_name:'"+fzigbeeota.head_str_name+"'");
	console.log("head_str_man:'"+fzigbeeota.head_str_man+"'");
	if(head.getUint32(0x08, true) != 0x544c4e4b){
		return "Incorrect head in Telink OTA binary firmware";
	}
	fzigbeeota.fwsize = head.getUint32(0x18, true);
	addAlog("FW size: 0x" + hex(fzigbeeota.fwsize,6)+" ("+fzigbeeota.fwsize+") bytes");
	if((fzigbeeota.fwsize > fsize) || ((fzigbeeota.fwsize & 0x0f) != 4)) {
		return "Invalid size pointer in Telink OTA binary firmware!";
	}
	let fcrc = new Uint32Array(2);
	fcrc[0] = crc32(new Uint8Array(data.slice(0, fzigbeeota.fwsize - 4)));
	fcrc[1] = (new DataView(data, fzigbeeota.fwsize - 4, 4)).getUint32(0, true);
	let s = "File CRC = 0x" + fcrc[1].toString(16) + ", Check CRC = 0x" + fcrc[0].toString(16);
	if(fcrc[0] != fcrc[1]) {
		return "Incorrect CRC in Telink OTA binary firmware! "+s;
	} else	addClog(s);
	if(!fzigbeeota.used) {
		fzigbeeota.man_code = head.getUint16(18,true);
		fzigbeeota.image_type = head.getUint16(20,true);
		fzigbeeota.fwversion = head.getUint32(2,true);
		fzigbeeota.stack_version = 2;
		fzigbeeota.used	= true;
		addAlog("Zigbee OTA Info: ManCode: 0x"+hex(fzigbeeota.man_code, 4)+ ", ImageType: 0x" + hex(fzigbeeota.image_type,4) + ", FwVer: 0x" + hex(fzigbeeota.fwversion, 8));
		addAlog("APP Release: " + ((fzigbeeota.fwversion >> 28)&0x0f) + "." + ((fzigbeeota.fwversion >> 24)&0x0f)
		+ " Build: " + ((fzigbeeota.fwversion >> 20)&0x0f) + "." + ((fzigbeeota.fwversion >> 16)&0x0f)
		+ ", Stack Version: " + ((fzigbeeota.fwversion >> 12)&0x0f) + "." + ((fzigbeeota.fwversion >> 8)&0x0f)
		+ " Release: " + ((fzigbeeota.fwversion >> 4)&0x0f) + "." + (fzigbeeota.fwversion&0x0f));
		addAlog("Added String: "+ fzigbeeota.head_str);
	}
	fzigbeeota.fname = fname;
	fzigbeeota.data = data;
	return "ok";
}

function getFwArray(data, filename) {
	addAlog("File: " + filename);
	let s = testOTAFirmware(data, filename);
	if(s != "ok") {
		addAlog(s);
		$("ldfrmw").innerHTML=s;
		fzigbeeota = { used : false };
		alert(s);
		return;
	}
	$("ldfrmw").innerHTML="file: "+ filename;
	menuUpgrade();
}

function ajax_file(filename, fn, rawurl = "https://raw.githubusercontent.com/pvvx/ZigbeeTLc/master/") {
	let xhr;
	if(window.XMLHttpRequest) xhr = new XMLHttpRequest();
	else if(window.ActiveXObject) xhr = new ActiveXObject("Microsoft.XMLHTTP")
	if (!xhr) { addClog(msg("Your browser does not support AJAX!")); fn(); return;};
	xhr.onreadystatechange = function() {
		if (xhr.readyState == 4) {
			if (xhr.status == 200) fn(xhr.response, filename);
			else { addClog('XMLHttpRequest: response ' + xhr.status); fn();}
			xhr.abort();
			xhr = null;
		}
	};
	xhr.ontimeout = function() { addClog('XMLHttpRequest: timeout'); fn();};
	xhr.onerror = function () { addClog('XMLHttpRequest error!'); fn();};
	xhr.open('GET', rawurl+filename, true);
	xhr.timeout = 10000;
	xhr.responseType = "arraybuffer";
	xhr.send();
}

function getOtaJson(d, name) {
	if (!d) {
		addAlog("No load index file!");
	} else {
		let str = '';
		if (typeof d === 'string')
			str = d;
		else
			str = new TextDecoder("utf-8").decode(d);
		let x = JSON.parse(str);
		if(x.version) {
			otafiles = x;
			otafiles.loaded = true;
			addClog(otafiles);
			if(otafiles.zbjson != null && otafiles.zbjson.slice(0,6) == "https:") {
				ajax_file(otafiles.zbjson, getZOtaJson, "" );
			}
			if(otafiles.zbdjson != null && otafiles.zbdjson.slice(0,6) == "https:") {
				ajax_file(otafiles.zbdjson, getZBOtaJson, "" );
			}
		}
	}
}

function getFirmwareArray(data, filename) {
 	getFwArray(data, filename, 0)
}

window.onload = function() {
	//addAlog("Load index file 'firmware.json'...");
	//ajax_file('firmware.json', getOtaJson);
	document.querySelector("#file").addEventListener("change", function() {
		let reader = new FileReader();
		reader.fname = "";
		reader.onload = function() {getFirmwareArray(this.result, this.fname);};
		if (this.files[0] != null) {
			reader.fname = this.files[0].name;
			reader.readAsArrayBuffer(this.files[0]);
		} else addAlog("No file selected"); }, false);
}

</script>
<h1>ZigbeeTLc Index Configurator for Zigbee OTA</h1>
<div class="navbar">
	<div class="container nav-container">
		<input class="checkbox" type="checkbox" name="" id="">
		<div class="hamburger-lines">
		  <span class="line line1"></span>
		  <span class="line line2"></span>
		  <span class="line line3"></span>
		</div>
	  <div class="menu-items">
		<li> GitHub </li>
		<li><a href="https://github.com/pvvx/ZigbeeTLc">Â© pvvx</a></li>
		<li> BLE Flasher </li>
		<li><a href="TelinkMiFlasher.html">TelinkMiFlasher</a></li>
		<li> USB Flasher </li>
		<li><a href="USBCOMFlashTx.html">Windows USB-COM Flasher</a></li>
	  </div>
	</div>
</div>
<hr>
<div style="height: auto; width: auto;">
 <div id="ldfile">
	Manual firmware download: <input type="file" accept=".zigbee,.ota,.bin" id="file"/></div>
 <div id="ldfrmw">Insert file name or file link</div>
 <hr>
 <b>Zigbee OTA Header:</b><br><br>	
 <label for="h_stack_version">Stack version in the header</label>
 <input type="text" id="h_stack_version" size="4" maxlength="6" value="" placeholder="0x0002"><br>
 <label for="h_man_code">Manufacture Code</label>
 <input type="text" id="h_man_code" size="4" maxlength="6" value="" placeholder="?"><br>
 <label for="h_image_type">Image Type</label>
 <input type="text" id="h_image_type" size="4" maxlength="6" value="" placeholder="?"><br>
 <label for="h_fwversion">Firmware and Stack version</label>
 <input type="text" id="h_fwversion" size="8" maxlength="10" value="" placeholder="?"><br>
 <label for="h_head_str">String in the Header</label>
 <input type="text" id="h_head_str" size="32" maxlength="32" value="" placeholder="?"> [man:name]<br>
  
 <button type="button" onclick="savefw();">Save new FW</button>
 <div>
 <hr>
 <button type="button" onclick="clearLog();">Clear Log</button>
 <div id="log"></div></div>
</body></html>