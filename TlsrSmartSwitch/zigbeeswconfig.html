<!DOCTYPE html>
<html class="telFlasherClass">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="styles.css">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TLSR825x Smart Switch FW Configurator v1.0</title>
</head>
<body>
<script>
var $ = function(id) { return document.getElementById(id);}
var fzigbeeota = { head_ok : false};
var otafiles;
const MIN_FW_OTA_SIZE = 1024; 
const MAX_FW_OTA_SIZE = 0x32000; 

const manufacturerNames = {
    0x7B: 'UHome',
    0x1002: 'Tuya',
    0x100B: 'Hue',
    0x1015: 'Develco',
    0x1021: 'Legrand',
    0x1037: 'Jennic',
    0x105E: 'SchneiderElectric',
    0x110C: 'Osram',
    0x1135: 'DresdenElektronik',
    0x1141: 'Telink',
    0x1144: 'Lutron',
    0x115C: 'Danalock',
    0x115F: 'Lumi',
    0x1160: 'Sengled',
    0x1166: 'Innr',
    0x117A: 'Insta',
    0x117C: 'IKEA',
    0x1189: 'Ledvance',
    0x1209: 'Bosch',
    0x1224: 'Namron',
    0x1228: 'Terncy',
    0x1233: 'ThirdReality',
    0x1246: 'Danfoss',
    0x124F: 'Gledopto',
    0x126A: 'EcoDim',
    0x1286: 'Sonoff',
    0x128B: 'NodOn',
    0x1337: 'Datek',
    0x130D: 'thirdreality',
    0x121C: 'Aurora',
    0x1407: '3R',
    0x2794: 'ClimaxTechnology',
    0x6565: 'Slacky-DIY',
    0x6666: 'Sprut.device',
    0xEA60: 'Telink-pvvx',
};


function addLog(logTXT) {
//	var time = new Date().toLocaleTimeString();
//	var logString = time + ": " + logTXT;
	$("log").innerHTML += logTXT + "<br>";
}

function addClog(logTXT) {
	console.log(logTXT);
}

function addErr(s) {
	console.log(s);
	se = "<font color='red'>" + s + "</font>";
	addLog(se);
	$("div_error").innerHTML=se;
}
function clrErr() {
	$("div_error").innerHTML="";
}

function addAlog(logTXT) {
	console.log(logTXT);
	addLog(logTXT);
}

function clearLog() {
	$("log").innerHTML = "";
}

function setStatus(status) {
	addClog("Status: " + status);
	$("percent").innerHTML = "Status: " + status;
}

function updateFail(err) {
	addLog("Update error: " + err);
	setStatus("Update error: " + err);
}

function decimalToHex(d, padding) {
	var hex = Number(d).toString(16);
	while (hex.length < 4) {
		hex = "0" + hex;
	}
	return hex;
}

function hex(number, len) {
	var str = (number.toString(16)).toUpperCase();
	while (str.length < len) str = '0' + str;
	return str;
}

function hexToBytes(hex) {
	for (var bytes = [], c = 0; c < hex.length; c += 2)
		bytes.push(parseInt(hex.substr(c, 2), 16));
	return new Uint8Array(bytes);
}

function bytesToHex(data) {
	return new Uint8Array(data).reduce(function(memo, i) {
		return memo + ("0" + i.toString(16)).slice(-2);
	}, "");
}

function hex2ascii(hexx) {
	var hex = hexx.toString();
	var str = '';
	for (var i = 0;
		(i < hex.length && hex.substr(i, 2) !== '00'); i += 2)
		str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
	return str;
}
var crc32 = (function() {
	let table = new Uint32Array(256);
	for(var i=256; i--;) {
		let tmp = i;
		for(let k=8; k--;) {
			tmp = tmp & 1 ? 0xEDB88320 ^ tmp >>> 1 : tmp >>> 1;
		}
		table[i] = tmp;
	}
	return function( data ) {
		let crc = -1;
		let l = data.length;
		for(let i=0; i<l; i++) {
			crc = crc >>> 8 ^ table[ crc & 255 ^ data[i] ];
		}
		return (crc >>> 0);
	};
})();


//-------------------------------------------------------------------------------------
function saveFile(blob, filename) {
    //const blob = new Blob([data], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);

    URL.revokeObjectURL(url);
}

function downloadFile(filename, content, type = 'text/plain') {
    const blob = new Blob([content], { type: type });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    console.log("a.download:"+a.download);
    document.body.removeChild(a);
    URL.revokeObjectURL(url); // Clean up the URL object
}


function showZigbeeHeaderValues() {
	if(fzigbeeota.head_ok) {
		$("h_stack_version").value = "0x" + hex(fzigbeeota.stack_version,4);
		$("h_man_code").value = "0x" + hex(fzigbeeota.man_code,4);
		$("h_image_type").value = "0x" + hex(fzigbeeota.image_type,4);
		$("h_fwversion").value = "0x" + hex(fzigbeeota.fwversion,8);
		$("h_head_str").value = fzigbeeota.head_str;
	}
}

function ReadZigbeeHeaderValues() {
	fzigbeeota.head_ok = false;
	let x = $("h_stack_version").value;
	if(x != "")	{ fzigbeeota.stack_version = parseInt(x);
		if(isNaN(fzigbeeota.stack_version) || fzigbeeota.stack_version == 0) {
		   fzigbeeota.stack_version = 2;
		   addAlog("Set default 'Header Stack version' = 2");
		}
	} else { 
		fzigbeeota.stack_version = 2;
	    addAlog("Set default 'Header Stack version' = 2");
	}
	x = $("h_man_code").value;
	if(x != "")	{ fzigbeeota.man_code = parseInt(x);
		if(isNaN(fzigbeeota.man_code) || fzigbeeota.man_code == 0) { addErr("Error Manufacture code!"); return false; };
	} else { addErr("Set Manufacture code!"); return false; };
	x = $("h_image_type").value;
	if(x != "")	{ fzigbeeota.image_type = parseInt(x);
		if(isNaN(fzigbeeota.image_type)) { addErr("Error Image Type!"); return false; };
	} else { addErr("Set Image Type!"); return false; };
	x = $("h_fwversion").value;
	if(x != "") { fzigbeeota.fwversion = parseInt(x); 
		if(isNaN(fzigbeeota.fwversion)) { addErr("Error FW and Stack version!"); return false; };
	} else { addErr("Set FW and Stack version!"); return false; };
	fzigbeeota.head_str = $("h_head_str").value;
	fzigbeeota.head_ok = true;
	return true;
}

function createZigbeeHeader() {
	let blk = new Uint8Array(0x3e);
	blk.set((new TextEncoder()).encode(fzigbeeota.head_str), 0x14, 0x34);
	let head = new DataView(blk.buffer);
	head.setUint32(0, 0x0beef11e, true); // Zigbee OTA
	head.setUint16(4, 0x100, true); // header version is 0x0100
	head.setUint16(6, 56, true); // header size
	//head.setUint16(8, 0, true); //	ota_ext_hdr_value if ota_ext_hdr else 0,
	head.setUint16(0x0a, fzigbeeota.man_code, true);
	head.setUint16(0x0c, fzigbeeota.image_type, true);
	head.setUint32(0x0e, fzigbeeota.fwversion, true);
	head.setUint16(0x12, fzigbeeota.stack_version, true);
	head.setUint32(0x34, fzigbeeota.fwsize + 62, true);
	head.setUint32(0x3a, fzigbeeota.fwsize, true);
	return head;
}

function menuUpdate() {
	showZigbeeHeaderValues();
	showTableGPIO();
}
//---------------------------------
function findInUint8Array(buffer, searchBytes) {
    const searchLength = searchBytes.length;
    const dataLength = buffer.length;
    for (let i = 0; i <= dataLength - searchLength; i++) {
        let found = true;
        for (let j = 0; j < searchLength; j++) {
            if (buffer[i + j] !== searchBytes[j]) {
                found = false;
                break;
            }
        }
        if (found) {
            return i;
        }
    }
    return null;
}
const ttab_gpio_nm = {
	ver: 0x0010,
	size: 7,
	name: [ 
	"GPIO flags",
	"GPIO Relay",
	"GPIO Led1",
	"GPIO Led2",
	"GPIO Key",
	"GPIO Switch",
	"GPIO Onewire"],
	none: 0x008,
	ns:   0x060,
	all: 7,
	def_data: [0, 0x0304, 0x0102, 0x0000, 0x0380, 0x0002, 0x0002]
};
const ttab_gpio_bl0937 = {
	ver: 0x0010,
	size: 10,
	name: [ 
	"GPIO flags",
	"GPIO Relay",
	"GPIO Led1",
	"GPIO Led2",
	"GPIO Key",
	"GPIO Switch",
	"GPIO Onewire",
	"GPIO BL0937 SEL",
	"GPIO BL0937 CF",
	"GPIO BL0937 CF1"],
	none: 0x008,
	ns:   0x060,
	all: 10,
	def_data: [0, 0x0304, 0x0102, 0x0000, 0x0380, 0x0002, 0x0002, 0x0308, 0x0110, 0x0120]
};
const ttab_gpio_bl0942 = {
	ver: 0x0010,
	size: 9,
	name: [ 
	"GPIO flags",
	"GPIO Relay",
	"GPIO Led1",
	"GPIO Led2",
	"GPIO Key",
	"GPIO Switch",
	"GPIO Onewire",
	"GPIO BL0942 TX",
	"GPIO BL0942 RX"],
	none: 0x008,
	ns:   0x060,
	all: 7,
	rx: [0x0001,0x0101,0x0180,0x0208,0x0220,0x0340],
	rxidx: 7,
	tx: [0x0004,0x0102,0x0204,0x0301,0x0308,0x0380], 
	txidx: 8,
	def_data: [0, 0x0208, 0x0110, 0x0000, 0x0120, 0x0304, 0x0304, 0x0180, 0x0102]
};

function getTableGPIO() {
	let ttab = null;
	if (fzigbeeota.data[18] != 0x60 ||  fzigbeeota.data[19] != 0xEA) { // man name: 60000=0xEA60
		$("tab_gpios").innerHTML = "<br>GPIO table not found!";
		addAlog("Unknown FW type!");
		return null;
	}
	let fwver = fzigbeeota.data[2] | (fzigbeeota.data[3]<<8);
	let type = (fzigbeeota.data[21] << 8) | fzigbeeota.data[20]; // image_type = gpio type
	console.log("GPIOs type: 0x" + hex(type,4));
	if((type & 0xff18) == 0x0100) {
		ttab = ttab_gpio_nm;
	} else if((type & 0xff18) == 0x0108) {
		ttab = ttab_gpio_bl0942;
	} else if((type & 0xff18) == 0x0110) {
		ttab = ttab_gpio_bl0937;
	} else {
		$("tab_gpios").innerHTML = "<br>GPIO table not found!";
		addAlog("Unknown FW type!");
		return null;
	}
	if (fwver < ttab.ver) {
		$("tab_gpios").innerHTML = "<br>Unsupported firmware version!";
		addAlog("Unsupported firmware version!");
		return null;
	}
	let pos = findInUint8Array(fzigbeeota.data, (new TextEncoder()).encode("TAB_GPIO"));
	if(pos) {
		pos += 8;
		fzigbeeota.gpio = {};
		fzigbeeota.gpio.pos = pos;
		fzigbeeota.gpio.type = type;
		fzigbeeota.gpio.fwver = fwver;
		fzigbeeota.gpio.ttab = ttab;
		fzigbeeota.gpio.data = new DataView(fzigbeeota.data.buffer.slice(pos, pos + ttab.size * 2));
		let s = "";
		for(i = 0; i < ttab.size; i++) {
			s += "0x"+hex(fzigbeeota.gpio.data.getUint16(i*2, true),4)
			if(i != ttab.size - 1) s += ", ";
		}
		addAlog("GPIO table found at 0x" + hex(pos-8, 6) + ", data: " + s);
	} else {
		$("tab_gpios").innerHTML = "<br>GPIO table not found!";
		addAlog("GPIO table not found!");
		return null;
	}
	return true;
}

function setTableGPIO() {
   	if(!fzigbeeota.gpio) return;
   	let not_use = fzigbeeota.gpio.ttab.ns;
	if((fzigbeeota.gpio.type & 0x0001) != 0) not_use = not_use & 0xbf;
	if((fzigbeeota.gpio.type & 0x0002) != 0) not_use = not_use & 0xdf;
	for(i = 1; i < fzigbeeota.gpio.ttab.size; i++) {
		if((not_use & (1<<i)) == 0) {
			let x = $("t_gpio"+i).value;
			if(x == "") x = fzigbeeota.gpio.ttab.def_data[i];
			fzigbeeota.gpio.data.setUint16(i*2, x, true);
//			console.log("t_gpio"+i+":"+hex(fzigbeeota.gpio.data.getUint16(i*2, true),4));
			$("t_gpio"+i).value = "0x" + hex(fzigbeeota.gpio.data.getUint16(i*2, true),4);
		} 
		// else { fzigbeeota.gpio.data.setUint16(i*2, fzigbeeota.gpio.ttab.def_data[i], true); }
		console.log("t_gpio"+i +":"+ hex(x,4));
	}
	let flg = ($("c_bit_led1").checked)? 1 : 0;
	flg += ($("c_bit_led2").checked)? 2 : 0;
	fzigbeeota.gpio.data.setUint16(0, flg, true);
}

function intToGpioName(x) {
	if(x  == 0)	return "None";
	if(x < 0 || x > 0x0408)	return "Error";
	let n = -1;
	for(let i = 0; i < 8; i++) {
		if((x & (1 << i)) != 0) {
			if(n == -1)	n = i;
			else return "Error"; 
		}
	}
	if(n == -1) return "Error";
	return "P" + hex(0xA0 + ((x & 0xf00) >> 4) + n, 2);
}

function showTableGPIO() {
   	if(!fzigbeeota.gpio) return;
   	let not_use = fzigbeeota.gpio.ttab.ns;
	if((fzigbeeota.gpio.type & 0x0011) != 0) not_use = not_use & 0xbf;
	if((fzigbeeota.gpio.type & 0x0100) != 0) not_use = not_use & 0xdf;
	console.log("GPIOs not use: 0x" + hex(not_use,2));
   	// select: GPIOs PA0..PE3
	let s = "";
	let options = ""; 
	for(i = 0; i < 4; i++) {
		for(x = 0; x < 8; x++) {
			let pbin = (i << 8) + (1 << x);	
			options += "<option value='0x"+hex(pbin, 4)+"'> "+intToGpioName(pbin)+" </option>";
		}
	}
	for(x = 0; x < 4; x++) {
		let pbin = 0x0400 + (1 << x);	
		options += "<option value='0x"+hex(pbin, 4)+"'> "+intToGpioName(pbin)+" </option>";
	}
	let select = "";
	for(i = 1; i < fzigbeeota.gpio.ttab.all; i++) {
		if((not_use & (1<<i)) == 0) {
			s += "<tr><td> " + fzigbeeota.gpio.ttab.name[i] + " </td><td><select id='t_gpio"+i+"'>";
			if((fzigbeeota.gpio.ttab.none & (1<<i)) != 0) s+= "<option value='0x0000'> None </option>";
			s += options+"</select></td><td> "+intToGpioName(fzigbeeota.gpio.ttab.def_data[i])+" </td></tr>";
		}
	}
	if(fzigbeeota.gpio.ttab.rx) {
		let idx = fzigbeeota.gpio.ttab.rxidx;
		options = "";
		for(i = 0; i < fzigbeeota.gpio.ttab.rx.length; i++) {
		  options += "<option value='0x"+hex(fzigbeeota.gpio.ttab.rx[i], 4)+"'> "+intToGpioName(fzigbeeota.gpio.ttab.rx[i])+" </option>";
		}
		s += "<tr><td> " + fzigbeeota.gpio.ttab.name[idx] + " </td><td><select id='t_gpio"+idx+"'>"+options+"</select></td><td> "+intToGpioName(fzigbeeota.gpio.ttab.def_data[idx])+" </td></tr>";
	}
	if(fzigbeeota.gpio.ttab.tx) {
		let idx = fzigbeeota.gpio.ttab.txidx;
		options = "";
		for(i = 0; i < fzigbeeota.gpio.ttab.rx.length; i++) {
		  options += "<option value='0x"+hex(fzigbeeota.gpio.ttab.tx[i], 4)+"'> "+intToGpioName(fzigbeeota.gpio.ttab.tx[i])+" </option>";
		}
		s += "<tr><td> " + fzigbeeota.gpio.ttab.name[idx] + " </td><td><select id='t_gpio"+idx+"'>"+options+"</select></td><td> "+intToGpioName(fzigbeeota.gpio.ttab.def_data[idx])+" </td></tr>";
	}
	s = "<br><b>GPIOS Table:</b><br><br><table id='tgpio' class='gpio_table'><tr><th>Name</th><th>GPIO</th><th>default</th></tr>"+s+"</table><br>";
	s += "<input type='checkbox' title='Inversion of LED1' id='c_bit_led1'><label>Inversion of LED1</label><br>";
	s += "<input type='checkbox' title='Inversion of LED2' id='c_bit_led2'><label>Inversion of LED2</label>";
	$("tab_gpios").innerHTML= s;
	for(i = 1; i < fzigbeeota.gpio.ttab.size; i++) {
		if((not_use & (1<<i)) == 0) {
			console.log("set t_gpio"+i +": 0x"+ hex(fzigbeeota.gpio.data.getUint16(i*2, true),4));
			$("t_gpio"+i).value = "0x" + hex(fzigbeeota.gpio.data.getUint16(i*2, true),4);
		}
	}
	let flg = fzigbeeota.gpio.data.getUint16(0, true);
	$("c_bit_led1").checked = ((flg & 0x01) !=0 ? 1 : 0);
	$("c_bit_led2").checked = ((flg & 0x02) !=0 ? 1 : 0);
}

function updateCRC(data) {
		const dcrc = new DataView(new ArrayBuffer(4));
		dcrc.setUint32(0, crc32(fzigbeeota.data.slice(0, fzigbeeota.fwsize - 4)), true);
		data.set(new Uint8Array(dcrc.buffer), fzigbeeota.fwsize - 4);
		addAlog("Update FW CRC = 0x" + hex(dcrc.getUint32(0, true),8));
}

function patchTableGPIO() {
   	if(!fzigbeeota.gpio) return;
   	setTableGPIO();
	let s = "";
   	fzigbeeota.data.set(new Uint8Array(fzigbeeota.gpio.data.buffer), fzigbeeota.gpio.pos); //, fzigbeeota.gpio.pos + fzigbeeota.gpio.ttab.size * 2);
	for(i = 0; i < fzigbeeota.gpio.ttab.size; i++) {
		s += "0x"+hex(fzigbeeota.gpio.data.getUint16(i*2, true),4)
		if(i != fzigbeeota.gpio.ttab.size - 1) s += ", ";
	}
	addAlog("Patch the GPIO table at 0x" + hex(fzigbeeota.gpio.pos-8, 6) + ", data: " + s);
	updateCRC(fzigbeeota.data);
}

//----------------------------------

function createFName() {
	let fname = hex(fzigbeeota.man_code, 4)
		+"-"+hex(fzigbeeota.image_type, 4)
		+"-"+hex(fzigbeeota.fwversion, 8)
	if(fzigbeeota.head_str_name != "")
		fname += "-" + fzigbeeota.head_str_name;
	return fname;
}


function createJson(fname) {
	const fileJson = {};
	fileJson.fileVersion = fzigbeeota.fwversion;
	fileJson.fileSize = fzigbeeota.fwsize + 0x3e;
	fileJson.manufacturerCode = fzigbeeota.man_code;
	fileJson.imageType = fzigbeeota.image_type;
	//fileJson.sha512 = "";
	fileJson.otaHeaderString = fzigbeeota.head_str;
	if(fzigbeeota.head_str_name != "")
		fileJson.modelId = fzigbeeota.head_str_name;
	if(fzigbeeota.head_str_man != "")
		fileJson.manufacturerName = [fzigbeeota.head_str_man];
	fileJson.url = "./" + fname + ".zigbee";
	return fileJson;
}

function saveNewFw(zbota) {
	if(ReadZigbeeHeaderValues()) {
		showZigbeeHeaderValues();
		let fname = createFName();
		if(zbota == 0) {
			fname += "-new.bin";
			patchTableGPIO();
			addAlog("Save bin file: " + fname);
			saveFile(new Blob([fzigbeeota.data], { type: 'application/octet-stream' }), fname);
		} else if(zbota == 1) {
			fname += "-new.zigbee";
			addAlog("Greate header file: "+fname);
			fzigbeeota.head = createZigbeeHeader();
			patchTableGPIO();
			addAlog("Save Zigbee OTA file: "+ fname);
			saveFile(new Blob([new Uint8Array(fzigbeeota.head.buffer), fzigbeeota.data], { type: 'application/octet-stream' }), fname);
		} else {
			let jfname = fname;
			//let jfname = "index";
			//if(fzigbeeota.head_str_name != "")
			//	jfname = fzigbeeota.head_str_name;
			jfname += ".json";
			addAlog("Greate Json file: " + jfname);
			saveFile(new Blob([JSON.stringify([createJson(fname+"-new")], null, '    ')], {type: 'application/json;charset=utf-8'}), jfname);
			addAlog("(!) Edit the resulting .json file to match the device names and paths to the Zigbee OTA update file (!)");
		}
	}
}

function buttonSaveNewFw(flg) {
	if(fzigbeeota.data)
		saveNewFw(flg);
	else
		addAlog("File Not loaded!");
}

function testOTAFirmware(data, fname) {
	fzigbeeota = { head_ok : false };
	$("bt_savefw").disabled = true;
	$("bt_savezota").disabled = true;
	$("bt_savejson").disabled = true;
	let fsize = data.byteLength;
	addClog("File size = 0x"+ fsize.toString(16));
	if (fsize < MIN_FW_OTA_SIZE)
		return "Wrong binary Telink OTA firmware size!";
	if (fsize > 1024*1024) // 1M
		return "The file size exceeds 1 Mbytes!";
	let	head = new DataView(data);
	if(head.getUint32(0, true) == 0x0beef11e) { // Zigbee OTA
		if(head.getUint16(4, true) != 0x100	|| head.getUint16(6, true) != 56)
			return "Unknown Zigbee OTA header!";
		fzigbeeota.size = head.getUint32(0x3A, true);
		if(fzigbeeota.size < 1024 || fzigbeeota.size + 0x3e > fsize)
			return "Wrong binary Zigbee OTA firmware size!";
		fzigbeeota.man_code = head.getUint16(0x0a, true);
		fzigbeeota.image_type = head.getUint16(0x0c, true);
		fzigbeeota.fwversion = head.getUint32(0x0e, true);
		fzigbeeota.stack_version = head.getUint16(0x12, true);
		fzigbeeota.head_str = (new TextDecoder("utf-8").decode(head.buffer.slice(0x14,0x34))).split('\u0000')[0];
		if(fzigbeeota.head_str) {
			fzigbeeota.head_str_name = fzigbeeota.head_str.substring(fzigbeeota.head_str.lastIndexOf(':')+1);
			if(fzigbeeota.head_str_name)
				fzigbeeota.head_str_man = fzigbeeota.head_str.substring(0, fzigbeeota.head_str.indexOf(':'));
			else { fzigbeeota.head_str_man = ""; fzigbeeota.head_str_name = ""; };
		} else { 
			fzigbeeota.head_str = ""; 
			fzigbeeota.head_str_man = ""; 
			fzigbeeota.head_str_name = ""; 
		};

		addAlog("Zigbee OTA Info: ManCode: 0x"+hex(fzigbeeota.man_code, 4)+ ", ImageType: 0x" + hex(fzigbeeota.image_type,4) + ", FwVer: 0x" + hex(fzigbeeota.fwversion, 8));
		addAlog("APP Release: " + ((fzigbeeota.fwversion >> 28)&0x0f) + "." + ((fzigbeeota.fwversion >> 24)&0x0f)
		+ " Build: " + ((fzigbeeota.fwversion >> 20)&0x0f) + "." + ((fzigbeeota.fwversion >> 16)&0x0f)
		+ ", Stack Version: " + ((fzigbeeota.fwversion >> 12)&0x0f) + "." + ((fzigbeeota.fwversion >> 8)&0x0f)
		+ " Release: " + ((fzigbeeota.fwversion >> 4)&0x0f) + "." + (fzigbeeota.fwversion&0x0f));
		addAlog("Header String: "+ fzigbeeota.head_str);
		if(fzigbeeota.fsize > MAX_FW_OTA_SIZE) // 200KB
			return "Size firmware is more "+(MAX_FW_OTA_SIZE/1024)+"kbytes!";

	 	head = new DataView(data, 0x3e, 0x3e + 28);
		fsize = fzigbeeota.size;

		fzigbeeota.fwsize = head.getUint32(0x18, true);
		addAlog("FW size: 0x" + hex(fzigbeeota.fwsize,6)+" ("+fzigbeeota.fwsize+") bytes");
		if((fzigbeeota.fwsize > fsize) || ((fzigbeeota.fwsize & 0x0f) != 4)) {
			return "Invalid size pointer in Telink OTA binary firmware!";
		}
		data = data.slice(0x3e, fzigbeeota.fwsize + 0x3e);

		let fcrc = new Uint32Array(2);
		fcrc[0] = crc32(new Uint8Array(data.slice(0, fzigbeeota.fwsize - 4)));
		fcrc[1] = (new DataView(data, fzigbeeota.fwsize - 4, 4)).getUint32(0, true);
		addAlog("FW CRC = 0x" + hex(fcrc[1],8) + ", Check CRC = 0x" + hex(fcrc[0],8))
		if(fcrc[0] != fcrc[1]) 
			return "Incorrect CRC in Telink OTA binary firmware! ";
		fzigbeeota.head_ok	= true;

	} else { // .bin file
		let addr_offset = 0;
		if(head.getUint32(0x08, true) != 0x544c4e4b) {
			if(fsize > 0x20400 && head.getUint32(0x20008, true) == 0x544c4e4b) { // BLE OTA
				addr_offset = 0x20000;
			} else if(fsize > 0x8400 && head.getUint32(0x8008, true) == 0x544c4e4b) { // Zigbee Boot
				addr_offset = 0x8000;
			} else if(fsize > 0x9400 && head.getUint32(0x9008, true) == 0x544c4e4b) { // Zigbee Boot
				addr_offset = 0x9000;
			} else if(fsize > 0x40400 && head.getUint32(0x40008, true) == 0x544c4e4b) { // Zigbee/BLE OTA 
				addr_offset = 0x40000;
			} else
    			return "This file is not for the TLSR825x chip!";
		} else {
			if(fsize > 0x8400 && head.getUint32(0x8008, true) == 0x544c4e4b) { // Zigbee Boot
				addr_offset = 0x8000;
			} else if(fsize > 0x9400 && head.getUint32(0x9008, true) == 0x544c4e4b) { // Zigbee Boot
				addr_offset = 0x9000;
			}
		}
		addAlog("Extracting an OTA binary file from address 0x"+hex(addr_offset,6)+"...");
   		if(fsize - addr_offset < MIN_FW_OTA_SIZE) {
			return "The firmware size is less than 1 kbytes!";
   		}
		head = new DataView(data.slice(addr_offset, addr_offset+28));
		                                                          
		fzigbeeota.fwsize = head.getUint32(0x18, true);
		addAlog("FW size: 0x" + hex(fzigbeeota.fwsize,6)+" ("+fzigbeeota.fwsize+") bytes");

		if((fzigbeeota.fwsize > fsize - addr_offset) || ((fzigbeeota.fwsize & 0x0f) != 4)) {
			return "Invalid size pointer in Telink OTA binary firmware!";
		}
		if(fzigbeeota.fwsize > MAX_FW_OTA_SIZE)
			return "Size firmware is more "+(MAX_FW_OTA_SIZE/1024)+" kbytes!";

		data = data.slice(addr_offset, fzigbeeota.fwsize + addr_offset);
		fsize = fzigbeeota.fwsize; 

		let fcrc = new Uint32Array(2);
		fcrc[0] = crc32(new Uint8Array(data.slice(0, fzigbeeota.fwsize - 4)));
		fcrc[1] = (new DataView(data, fzigbeeota.fwsize - 4, 4)).getUint32(0, true);
		addAlog("FW CRC = 0x" + hex(fcrc[1],8) + ", Check CRC = 0x" + hex(fcrc[0],8))
		if(fcrc[0] != fcrc[1]) 
			return "Incorrect CRC in Telink OTA binary firmware! ";
		fzigbeeota.man_code = head.getUint16(18,true);
		fzigbeeota.image_type = head.getUint16(20,true);
		fzigbeeota.fwversion = head.getUint32(2,true);
		fzigbeeota.stack_version = 2;
        fzigbeeota.head_str = "";
        fzigbeeota.head_str_man = "";
        fzigbeeota.head_str_name = "";
		if(fzigbeeota.man_code != 0
		 &&	fzigbeeota.image_type != 0
		 &&	fzigbeeota.fwversion != 0
		 &&	fzigbeeota.stack_version != 0) {
	        if (!manufacturerNames[fzigbeeota.man_code]) {
		        fzigbeeota.head_str_man = "";
	        } else {
	        	fzigbeeota.head_str_man = manufacturerNames[fzigbeeota.man_code];
	        }
			let fn = fname.substring(fname.lastIndexOf('/')+1);
			fzigbeeota.head_str_name = fn.substring(0, fn.lastIndexOf('.'));
			if(!fzigbeeota.head_str_name)
				fzigbeeota.head_str_name = fn.substring(fn.lastIndexOf('.')+1);
			if(fzigbeeota.head_str_name) {
				fzigbeeota.head_str = fzigbeeota.head_str_man + ":" + fzigbeeota.head_str_name;
			} else fzigbeeota.head_str_name = "";

			addAlog("Zigbee OTA Info: ManCode: 0x"+hex(fzigbeeota.man_code, 4)+ ", ImageType: 0x" + hex(fzigbeeota.image_type,4) + ", FwVer: 0x" + hex(fzigbeeota.fwversion, 8));
			addAlog("APP Release: " + ((fzigbeeota.fwversion >> 28)&0x0f) + "." + ((fzigbeeota.fwversion >> 24)&0x0f)
			+ " Build: " + ((fzigbeeota.fwversion >> 20)&0x0f) + "." + ((fzigbeeota.fwversion >> 16)&0x0f)
			+ ", Stack Version: " + ((fzigbeeota.fwversion >> 12)&0x0f) + "." + ((fzigbeeota.fwversion >> 8)&0x0f)
			+ " Release: " + ((fzigbeeota.fwversion >> 4)&0x0f) + "." + (fzigbeeota.fwversion&0x0f));
			addAlog("Added `Header String`: '"+ fzigbeeota.head_str+"'");
		  	fzigbeeota.head_ok	= true;
		}
		addAlog("Specify the name of the manufacturer and device using the ':' symbol in the head `Header String`.");
		addAlog("Or describe the type of firmware, without using the ':' symbol.");
	}
	fzigbeeota.fname = fname;
	fzigbeeota.data = new Uint8Array(data);
	getTableGPIO();
	$("bt_savefw").disabled = false;
	$("bt_savezota").disabled = false;
	$("bt_savejson").disabled = false;
	return "ok";
}

function getFwArray(data, filename) {
	clrErr();
	fzigbeeota.filename = filename.substring(filename.lastIndexOf('/')+1)
	addAlog("File: <b>" + fzigbeeota.filename + "</b>");
	$("div_status").innerHTML="File: <b>"+ fzigbeeota.filename + "</b>";
	let s = testOTAFirmware(data, fzigbeeota.filename);
	if(s != "ok") {
		addErr(s);
		fzigbeeota = { head_ok : false};
		alert(s);
		return;
	}
	menuUpdate();
}

function loadFirmware(id) {
	let fn = otafiles.TlsrSmartSwitch[id];
	addAlog("Downloading firmware file '"+fn+"'...");
	if(fn.slice(0,6) == "https:")
		ajax_file(fn, getFirmwareArray, "");
	else
		ajax_file(fn, getFirmwareArray);
}

function chowOtaFiles() {
	if(!otafiles.loaded || !otafiles.TlsrSmartSwitch)
		return;
	if(otafiles.TlsrSmartSwitch.length > 0) {
		let is = "<b>Basic firmwares:</b><br>";
		for(let i = 0; i < otafiles.TlsrSmartSwitch.length; i++) {
			let fn = otafiles.TlsrSmartSwitch[i];
			if(fn != null && fn != "" && fn != "?" && fn != "/") {
				try {
					if(fn.slice(0,6) == "https:")
						fn = (new URL(fn)).pathname.split("/").pop();
				} catch (error) {
					console.log(error);
				}
				fn = fn.substring(fn.lastIndexOf('/')+1);
				is += "<button type='button' id='but_fn"+i+"' onclick='loadFirmware("+i+");'>" + fn + "</button>";
				if(i&1) is += "<br>";
			}
		}
		$("ldfile").innerHTML = is;
		$("ldfile").hidden = false;
	}
}

function ajax_file(filename, fn, rawurl = "https://raw.githubusercontent.com/pvvx/TlsrSmartSwitch/master/") {
	let xhr;
	if(window.XMLHttpRequest) xhr = new XMLHttpRequest();
	else if(window.ActiveXObject) xhr = new ActiveXObject("Microsoft.XMLHTTP")
	if (!xhr) { addClog(msg("Your browser does not support AJAX!")); fn(); return;};
	xhr.onreadystatechange = function() {
		if (xhr.readyState == 4) {
			if (xhr.status == 200) fn(xhr.response, filename);
			else { addClog('XMLHttpRequest: response ' + xhr.status); fn();}
			xhr.abort();
			xhr = null;
		}
	};
	xhr.ontimeout = function() { addClog('XMLHttpRequest: timeout'); fn();};
	xhr.onerror = function () { addClog('XMLHttpRequest error!'); fn();};
	xhr.open('GET', rawurl+filename, true);
	xhr.timeout = 10000;
	xhr.responseType = "arraybuffer";
	xhr.send();
}

function getOtaJson(d, name) {
	if (!d) {
		addAlog("No load index file!");
	} else {
		let str = '';
		if (typeof d === 'string')
			str = d;
		else
			str = new TextDecoder("utf-8").decode(d);
		let x = JSON.parse(str);
		if(x.TlsrSmartSwitch) {
			otafiles = x;
			otafiles.loaded = true;
			console.log(otafiles);
			chowOtaFiles();
		}
	}
}

function getFirmwareArray(data, filename) {
 	getFwArray(data, filename, 0)
}

window.onload = function() {
	addAlog("Downloading index file 'firmware.json' from GitHub...");
	ajax_file('firmware.json', getOtaJson);
	document.querySelector("#file").addEventListener("change", function() {
		let reader = new FileReader();
		reader.fname = "";
		reader.onload = function() {getFirmwareArray(this.result, this.fname);};
		if (this.files[0] != null) {
			reader.fname = this.files[0].name;
			reader.readAsArrayBuffer(this.files[0]);
		} else addAlog("No file selected"); }, false);
}

</script>
<h1>TLSR825x Smart Switch FW Configurator</h1>
<div class="navbar">
	<div class="container nav-container">
		<input class="checkbox" type="checkbox" name="" id="">
		<div class="hamburger-lines">
		  <span class="line line1"></span>
		  <span class="line line2"></span>
		  <span class="line line3"></span>
		</div>
	  <div class="menu-items">
		<li> GitHub </li>
		<li><a href="https://github.com/pvvx/TlsrSmartSwitch">Â© pvvx</a></li>
		<li> BLE Flasher </li>
		<li><a href="TelinkMiFlasher.html">TelinkMiFlasher</a></li>
		<li> USB Flasher </li>
		<li><a href="USBCOMFlashTx.html">Windows USB-COM Flasher</a></li>
	  </div>
	</div>
</div>
<hr>
<div style="height: auto; width: auto;">
 <div id="ldfile" hidden="true"></div>
 <div id="div_ldfile">
	Manual firmware download: <input type="file" accept=".zigbee,.ota,.bin" id="file"/></div>
 <div id="div_status"><i>Info:</i><br>1. In the file upload menu, paste the file name or link to the file containing ZigbeeOTA, or OTA FW, or FullFlash.bin for TlsrSmartSwitch.<br>
 2. To clear the file cache, cancel the file download, then select the file again.</div>
 <div id="div_error"></div>
 <hr>
 <b>Zigbee OTA Header:</b><br><br>	
 <label for="h_stack_version">Header Stack version</label>
 <input type="text" id="h_stack_version" size="4" maxlength="6" value="" placeholder="0x0002"><br>
 <label for="h_man_code">Manufacture Code</label>
 <input type="text" id="h_man_code" size="4" maxlength="6" value="" placeholder="?"><br>
 <label for="h_image_type">Image Type</label>
 <input type="text" id="h_image_type" size="4" maxlength="6" value="" placeholder="?"><br>
 <label for="h_fwversion">Firmware and Stack version</label>
 <input type="text" id="h_fwversion" size="8" maxlength="10" value="" placeholder="?"><br>
 <label for="h_head_str">Header String</label>
 <input type="text" id="h_head_str" size="32" maxlength="32" value="" placeholder="?"> [man:name]<br>
 <div id="tab_gpios"></div><br>
 <button type="button" id="bt_savefw" disabled="true" onclick="buttonSaveNewFw(0);">Save FW bin</button>
 <button type="button" id="bt_savezota" disabled="true" onclick="buttonSaveNewFw(1);">Save Zigbee OTA</button>
 <button type="button" id="bt_savejson" disabled="true" onclick="buttonSaveNewFw(2);">Save Json</button>
 <div><hr>
 <button type="button" onclick="clearLog();">Clear Log</button>
 <div id="log"></div></div>
</body></html>